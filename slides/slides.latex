% Copyright (c) 2015, Christopher Mark Gore,
% Soli Deo Gloria,
% All rights reserved.
%
% 2317 South River Road, Saint Charles, Missouri 63303 USA.
% Web: http://cgore.com
% Email: cgore@cgore.com
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
%     * Redistributions of source code must retain the above copyright
%       notice, this list of conditions and the following disclaimer.
%
%     * Redistributions in binary form must reproduce the above copyright
%       notice, this list of conditions and the following disclaimer in the
%       documentation and/or other materials provided with the distribution.
%
%     * Neither the name of Christopher Mark Gore nor the names of other
%       contributors may be used to endorse or promote products derived from
%       this software without specific prior written permission.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.

\documentclass{seminar}

\usepackage{fixltx2e} % Bugfixes for LaTeX 2e
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[normalem]{ulem}
\usepackage{graphicx}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{librebaskerville} % Baskerville font
\usepackage{amsfonts}
\usepackage{listings}
\usepackage[dvips]{pstricks}
\usepackage{relsize}
\usepackage{textcomp}
\usepackage[normalem]{ulem}
\usepackage{wasysym}
\usepackage{dirtree}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{pifont}
\usepackage{tikz}

\usetikzlibrary{positioning,shapes,shadows,arrows}
\tikzstyle{module}=[draw,fill=white]
\tikzstyle{class}=[module, drop shadow]
\tikzstyle{detailedClass}=[class, rectangle split, rectangle split parts=2]
\tikzstyle{instance}=[draw,ellipse,fill=white,text=blue]
\tikzstyle{subclass}=[-open triangle 60, thick]
\tikzstyle{mixin}=[-open triangle 60, dashed]
\tikzstyle{instanceOf}=[->, thick]

\usepackage{semcolor,slidesec}
\input{seminar.bug}
\input{seminar.bg2}
% \input{seminar.bg3} % TODO: why is this missing on OSX?

\definecolor{fillcolor}{rgb}{0.9,0.95,1.0}
\definecolor{linecolor}{rgb}{0.8,0.85,0.9}
\slideframe[\psset{fillcolor=fillcolor,linecolor=linecolor}]{scshadow}

\newcommand{\hc}{Blue}
\newcommand{\h}[1]{\slideheading{\textcolor{\hc}{#1}}}
\newcommand{\tq}[1]{\textcolor{Green}{\textbf{#1}}}
\newcommand{\tbd}[1]{\textcolor{Blue}{\textit{#1}}}
\newcommand{\TODO}{{\Huge \textcolor{Red}{\textbf{{TO DO}}}}}

\definecolor{commentcolor}{rgb}{0.1,0.1,0.8}
\definecolor{identifiercolor}{rgb}{0.3,0.3,0.3}
\definecolor{keywordcolor}{rgb}{0.1,0.5,0.1}
\definecolor{cexcolor}{rgb}{0.25,0.25,0.4}
\lstset{
  basicstyle=\footnotesize\ttfamily,
  language=Lisp,
  morekeywords={make-instance},
  escapeinside={\%*}{*)},
  commentstyle=\itshape\color{commentcolor},
  identifierstyle=\color{identifiercolor},
  keywordstyle=\color{keywordcolor},
  upquote=true,
  numbers=left,
  numberstyle=\tiny\color{commentcolor},
  numbersep=5pt
}
\newcommand{\cex}[1]{\textcolor{cexcolor}{\textit{#1}}}

\newcommand{\shell}[1]{\texttt{\textbf{{\textcolor{Blue} \$}} #1}}

\newcommand{\xmark}{\textcolor{Red}{\ding{55}}}
\newcommand{\cmark}{\textcolor{Green}{\ding{51}}}

\newcommand{\SlideSection}[1]
{
  \begin{center}
    \textcolor{\hc}{\textbf{\emph{\Huge{#1}}}}
  \end{center}
}


\newcommand{\fullSlideImage}[1]{
  \begin{center}
    \includegraphics[width=4in,height=2.5in,keepaspectratio=true]{#1}
  \end{center}
}

\newcommand{\halfSlideImage}[1]{
  \includegraphics[width=2in,height=2.5in,keepaspectratio=true]{#1}
}

\newcommand{\rightSideImageName}{you-must-supply-the-image-name.eps}
\newenvironment{rightSideImage}[1]
{
  \renewcommand{\rightSideImageName}{#1}
  \begin{tabular}{lr}
    \begin{minipage}[b]{2in}
}
{
    \end{minipage}
    &
    \halfSlideImage{\rightSideImageName}
  \end{tabular}
}

\title{\psshadowbox{Clojure Schemata and Generators}}
\author{Christopher Mark Gore\\
  \texttt{cgore.com}}
\date{Tuesday, September 29, {\smaller AD} 2015} % textsc doesn't seem to work for Baskerville.

\begin{document}

\raggedslides[0mm]


\begin{slide}
  \color{\hc}

  \begin{center}
    \includegraphics[height=1.25in]{STLClojure.eps}
  \end{center}

  \maketitle

  \color{Black}
\end{slide}


\begin{slide}
  \h{We Write Clojure at The Climate Corporation,\\And We're Hiring!}
  \fullSlideImage{climate-logo-bluebg.eps}
\end{slide}


\begin{slide}
  \h{Add Stuff to Your \texttt{project.clj}}

\begin{lstlisting}
(defproject your-project "1.2.3"
  :description "It's like totally awesome and stuff"
  ;; ...
  :dependencies [;;...
                 [prismatic/schema "0.4.3"]
                 [org.clojure/test.check "0.7.0"]
                 ;; ...
                 ]
  ;; ...
  )
\end{lstlisting}
\end{slide}


\begin{slide}
  \h{Prismatic Schema}

  Schemata%
  \footnote{The plural of \textit{schema} is \textit{schemata}, not
    \textit{schemas.}}
  are sort of like types, but only as strict as you want them to be at
  that specific moment, so no type hell.

\begin{lstlisting}
(ns schema-stuff
  (:require [schema.core :as s]))

(s/validate s/Num 42)
(s/validate s/Str "howza")
(s/validate s/Keyword :hey)
\end{lstlisting}
\end{slide}


\begin{slide}
  \h{Clojure \texttt{test.check} and Generators}

  Generators make random examples according to a definition.  It's a great way
  to make test data without brittle hand-rolled examples.

\begin{lstlisting}
(ns gen-stuff
  (:require [clojure.test.check :as tc]
            [clojure.test.check.generators :as gen]
            [clojure.test.check.properties :as prop]

(gen/sample gen/int)
;; => (0 1 -1 0 -1 4 4 2 7 1)
(gen/sample gen/int 20)
;; => (0 1 1 0 2 -4 0 5 -7 -8 4 5 3 11 -9 -4 6 -5 -3 0)
\end{lstlisting}
\end{slide}


\begin{slide}
  \h{Schemata + Generators = Awesome!}

  \begin{itemize}
  \item Schemata to validate function input
    \begin{itemize}
    \item Definitely in tests.
    \item Maybe even in production.
    \end{itemize}
  \item Generators to fuzz the function in tests.
  \item Feed the generators into the schemata.
    \begin{itemize}
    \item Check the generator against the schema.
    \item Check the schema with the generator.
    \end{itemize}
  \end{itemize}
\end{slide}


\begin{slide}
  \h{Schemata are These}

  \fullSlideImage{paint-by-number.eps}
\end{slide}


\begin{slide}
  \h{Generators are These}

  \fullSlideImage{1964brassau01.eps}
\end{slide}


\begin{slide}
  \h{Used Together, We Catch When Our Code Does This}

  \fullSlideImage{modern-art.eps}
\end{slide}


\begin{slide}
  \h{Schema: \texttt{validate} versus \texttt{check}}

  The two most important functions for schema checks are \texttt{validate} and
  \texttt{check}, the only real difference being that \texttt{validate} raises
  an error and check does not.

\begin{lstlisting}
;; A schema for integers.
(s/validate s/Int 42) ; passes, returns 42
(try (s/validate s/Int "nope") ; fails, throws an error.
     (catch Exception e))

(s/check s/Int 42) ; => nil
(s/check s/Int "nope") ; => (not (integer? "nope"))
\end{lstlisting}
\end{slide}


\begin{slide}
  \h{Test Check Properties}

  We define properties we expect to always hold, and assert those properties.

\begin{lstlisting}
(def prop-addition-increments
  (prop/for-all [a gen/int
                 b gen/int]
                (>= (+ a b) a))) ; This is always true.
;; Check 100 times
(tc/quick-check 100 prop-addition-increments)
;; FAIL!  We forgot negatives!
{:result false, :seed 1434746134125, :failing-size 2,
 :num-tests 3, :fail [1 -2],
 :shrunk {:total-nodes-visited 4, :depth 2, :result false,
          :smallest [0 -1]}}
\end{lstlisting}
\end{slide}


\begin{slide}
  \h{Test Check Properties}

  We discover the \textit{real properties} of our system this way, not just what
  we \textit{think} they are.

  $$\left[a+b \ge a\right] \forall a,b \in \mathbb{N} = \mathbb{Z} \cap [0,\infty)$$

\begin{lstlisting}
;; We meant for natural numbers [0,...)%*\footnote{Somebody with a Ph.D. in mathematics might have told you that 0 isn't a natural number: they are wrong.} *)
(def prop-addition-increments-for-nat
  (prop/for-all [a gen/nat
                 b gen/nat]
                (>= (+ a b) a))) ; This is REALLY true
;; Check 100 times
(tc/quick-check 100 prop-addition-increments-for-nat)
;; => {:result true, :num-tests 100, :seed 1434746600412}
\end{lstlisting}
\end{slide}


\begin{slide}
  \h{Our Schemata are Our Properties}

  Our schema must accept \textit{all} instances, if not, it's not a valid
  schema, therefore we can state that the schema is a property \textit{for all}
  of our generated examples.

\begin{lstlisting}
(def Person {:name s/Str
             :age s/Int}) ; We'll make s/Nat in a bit.
(def person (gen/hash-map :name gen/string
                          :age gen/nat))
(def prop-person-generates-Person
  (prop/for-all [p person]
                (s/validate Person p)))
(tc/quick-check 100 prop-person-generates-Person)
\end{lstlisting}
\end{slide}


\begin{slide}
  \h{Integrating \texttt{test.check} and \texttt{clojure.test}}

  There is a \texttt{defspec} macro to parallel \texttt{deftest} at\\
  \texttt{clojure.test.check.clojure-test/defspec}.

\begin{lstlisting}
(defspec first-element-is-min-after-sorting
         100 ; the number of iterations
         (prop/for-all [v (gen/not-empty
                            (gen/vector gen/int))]
           (= (apply min v)
              (first (sort v)))))
\end{lstlisting}
\end{slide}


\begin{slide}
  \h{Names are Great, Two Are Better!}

  \begin{tabular}{lll}
    \textbf{What is it} & \textbf{Schema} & \textbf{Generator} \\

    strings &
    \texttt{s/Str} &
    \texttt{gen/string} \\

    real numbers &
    \texttt{s/Num} &
    \textit{missing} \\

    $\mathbb{Z} = \{\ldots, -2,-1, 0, 1, 2, \ldots\}$ &
    \texttt{s/Int} &
    \texttt{gen/int} \\

    $\mathbb{N} = \{0, 1, 2, \ldots\}$ &
    \textit{missing} &
    \texttt{gen/nat} or \texttt{gen/pos-int}\\

    $\mathbb{Z}^+ = \mathbb{N} \setminus \{0\}$ &
    \textit{missing} &
    \texttt{gen/s-pos-int} \\

    $\mathbb{Z}^-$ &
    \textit{missing} &
    \texttt{gen/s-neg-int} \\

    $\mathbb{Z}^- \cup \{0\}$ &
    \textit{missing} &
    \texttt{gen/neg-int}
  \end{tabular}
\end{slide}


\begin{slide}
  \h{That's a Lot of Missing Things!}

  \fullSlideImage{missing-milk-carton-clojure.eps}
\end{slide}


\begin{slide}
  \h{Existing Generators: Bits and Bytes}

  \begin{description}
  \item[\texttt{gen/boolean}] Either \texttt{true} or \texttt{false}.
    \begin{lstlisting}
      (gen/sample gen/boolean)
      ;; => (false true false true true
      ;;     false false false false true)
    \end{lstlisting}
  \item[\texttt{gen/byte}] A single \texttt{java.lang.Byte}.
    \begin{lstlisting}
      (gen/sample gen/byte)
      ;; => (-88 101 101 104 24 -37 -36 9 20 107)
    \end{lstlisting}
  \item[\texttt{gen/bytes}] A \texttt{byte-array}.
    \begin{lstlisting}
      (gen/sample gen/bytes)
      ;; => (#<byte[] [B@2efce23e> ...)
    \end{lstlisting}
  \end{description}
\end{slide}


\begin{slide}
  \h{Existing Generators: Numbers}

  \begin{description}
  \item[\texttt{gen/int}] Any integer.
    \begin{lstlisting}
      (gen/sample gen/int)
      ;; => (0 -1 1 2 3 -2 -3 3 5 -2)
    \end{lstlisting}
  \item[\texttt{gen/choose}] Numbers in the specified range.
    \begin{lstlisting}
      (gen/sample (gen/choose 18 45)
      ;; => (24 34 33 37 27 29 29 32 44 18)
    \end{lstlisting}
  \item[\texttt{gen/nat}] Natural numbers: positive integers and $0$.
  \item[\texttt{gen/pos-int} and \texttt{gen/neg-int}] Postive-only or
    negative-only integers, allowing for $0$.
  \item[\texttt{gen/s-pos-int} and \texttt{gen/s-neg-int}] Postive-only or
    negative-only integers, \textbf{not} allowing for $0$.
  \end{description}
\end{slide}


\begin{slide}
  \h{Existing Generators: Characters and Strings}

  \begin{description}
  \item[\texttt{gen/char}] Any character.
  \item[\texttt{gen/char-ascii}] ASCII-only characters.
  \item[\texttt{gen/char-alphanumeric}] Alphanumeric characters, a--z, A--Z and 0--9.
  \item[\texttt{gen/char-alpha}] Alpha-only characters, a--z and A--Z.
  \item[\texttt{gen/string}] Any string, \textit{including weird characters}.
  \item[\texttt{gen/string-ascii}] ASCII-only strings.
    \begin{lstlisting}
      (gen/sample gen/string-ascii)
      ;; => ("" "" "qc" "I-k" "F" ""
      ;;     ", Ou" "6kT]<" "}`!" "5ZH=v75")
    \end{lstlisting}
  \item[\texttt{gen/string-alphanumeric}] Alphanumeric strings.
  \end{description}
\end{slide}


\begin{slide}
  \h{Existing Generators: Collections}

  \begin{description}
  \item[\texttt{gen/tuple}] A vector in a specific order.
    \begin{lstlisting}
      (gen/sample (gen/tuple gen/int gen/string-ascii))
      ;; => ([0 ""] [0 ""] [-2 "KY"] [0 "J\\"] [4 "n"]
      ;;     [-2 "\\"] [-2 ";%HJCM"] [-2 "QwD"]
      ;;     [1 "]KLY|P"] [6 "g"])
    \end{lstlisting}
  \item[\texttt{gen/vector}] A vector of generated things.
    \begin{lstlisting}
      (gen/sample (gen/vector gen/int))
      ;; => ([] [] [] [1] [] [0 5 -1 0 5] [5 5 3]
      ;;     [-6 3 -1] [7 -7 -6 2 0 -5 3 -7]
      ;;     [-9 -4 4 -6 -5 0])
    \end{lstlisting}
  \item[\texttt{gen/list}] A list of generated things, instead of a vector.
  \end{description}
\end{slide}


\begin{slide}
  \h{Existing Generators: Collections}

  \begin{description}
  \item[\texttt{gen/shuffle}] Randomly permute a sequence.
    \begin{lstlisting}
      (gen/sample (gen/shuffle [1 2 3]))
      ;; => ([1 2 3] [3 1 2] [1 2 3] [2 3 1] [1 3 2]
      ;;     [2 1 3] [2 1 3] [2 1 3] [1 3 2] [3 1 2])
    \end{lstlisting}
  \item[\texttt{gen/map}] Generate maps with both the key and value being generated.
    \begin{lstlisting}
      (gen/sample
        (gen/map (gen/elements [:bibbidi :bobbidi :boo])
                               gen/int))
      ;; => ({} {:bobbidi -1} {}
      ;;     {:bobbidi -2, :bibbidi -3}
      ;;     {:boo 2, :bobbidi -2}
      ;;     {:boo -2, :bobbidi -1}
      ;;     {:boo -1, :bibbidi -5} {} {} {:bibbidi 2})
    \end{lstlisting}
  \end{description}
\end{slide}


\begin{slide}
  \h{Existing Generators: Collections}

  \begin{description}
  \item[\texttt{gen/hash-map}] You'll use this a lot.
    \begin{lstlisting}
      (gen/sample
        (gen/hash-map :bibbidi gen/int
                      :bobbidi gen/string-ascii
                      :boo (gen/return 4077)))
      ;; => ({:boo 4077, :bobbidi "",    :bibbidi  0}
      ;;     {:boo 4077, :bobbidi "H",   :bibbidi  0}
      ;;     {:boo 4077, :bobbidi "",    :bibbidi  0}
      ;;     {:boo 4077, :bobbidi "8B",  :bibbidi -3}
      ;;     {:boo 4077, :bobbidi "OY",  :bibbidi  1}
      ;;     {:boo 4077, :bobbidi "a&)", :bibbidi -5}
      ;;     {:boo 4077, :bobbidi "",    :bibbidi  0}
      ;;     ...)
    \end{lstlisting}
  \end{description}
\end{slide}


\begin{slide}
  \h{Using \texttt{gen/elements}}

  Randomly pick (without exhaustion) from a collection.

\begin{lstlisting}
(gen/sample
  (gen/elements [:spades :diamonds :hearts :clubs]))
;; => (:diamonds :clubs :spades :clubs :hearts
;;     :spades :spades :hearts :hearts :hearts)
\end{lstlisting}
\end{slide}


\begin{slide}
  \h{Making New Generators With \texttt{gen/fmap}}

  If nothing makes sense to generate your stuff, there's always
  \texttt{gen/fmap}, and then you can use any function you want. Huzzah,
  Clojure!

%% TODO: better example.

\begin{lstlisting}
(def even-and-positive (gen/fmap #(* 2 %) gen/pos-int))
(gen/sample even-and-positive 20)
;; => (0 0 2 0 8 6 4 12 4 18 10 0 8 2 16 16 6 4 10 4)
(def gen-double (gen/fmap rand gen/int)
(gen/sample gen-double)
;; => (0.0                 0.0
;;     0.8433531349313175 -0.5407298249526976
;;     0.7282154724842486 -0.5111220285736056
;;    -1.6998294599186186  1.4744104363479704
;;     2.094621081981671  -1.7704991357273019)
\end{lstlisting}
\end{slide}


\begin{slide}
  \h{Making New Generators With \texttt{gen/bind}}

  The \texttt{gen/bind} is sort of like \texttt{gen/fmap}: it takes in a
  generator and a function, but feeds the realized generated things into the
  function to make a new generator.  It's basically for when you want a let block.

\begin{lstlisting}
(gen/sample
  (gen/bind (gen/not-empty gen/string-ascii)
            #(gen/hash-map :str (gen/return %)
                           :key (gen/return (keyword %)))))
;; => ({:key :2,   :str "2"}
;;     {:key :+,   :str "+"}
;;     {:key :Nm,  :str "Nm"}
;;     {:key :Z|>, :str "Z|>"}
;;     ...)
\end{lstlisting}
\end{slide}


\begin{slide}
  \h{Modifying Existing Generators}

  \begin{description}
  \item[\texttt{gen/not-empty}] Empty collections are sometimes irritating.
    \begin{lstlisting}
      (gen/sample (gen/vector gen/int))
      ;; => ([] ; DO NOT WANT
      ;;     [-1] [0] [3 -3] [-1 0 2 0] [4]
      ;;     [5 -5] [2 1 -6 -1 2] [-1 -7 -7]
      ;;     [-5 6 -1 -4])
      (gen/sample (gen/not-empty (gen/vector gen/int)))
      ;; => ([-1] [-2 2] [2 -2] [2] [2 0] [3 -6]
      ;;     [1 -5 0 4] [5 -2 -2 -3 -3 -4 5]
      ;;     [-2 7 2 -3] [7 6 -4])
    \end{lstlisting}
  \item[\texttt{gen/no-shrink}] I've never used this: it's weird?  Shrinking is
    weird in general.
  \end{description}
\end{slide}


\begin{slide}
  \h{Modifying Existing Generators}

  \begin{description}
  \item[\texttt{gen/such-that}] Add a simple requirement to an existing
    generator, rejecting things that don't pass the predicate.
    \begin{lstlisting}
      (gen/sample (gen/such-that #(< 3 %) gen/int))
      ;; => (4 4 9 6 4 5 6 6 4 9)
    \end{lstlisting}
  \item[\texttt{gen/sized}] Make a generator that is dependent on a
    \textit{size} concept of some sort.
    \begin{lstlisting}
      (gen/sample (gen/sized #(gen/choose 0 %)))
      ;; => (0 0 2 0 1 5 4 5 0 4)
    \end{lstlisting}
  \item[\texttt{gen/resize}] Change the size.
    \begin{lstlisting}
      (gen/sample
        (gen/resize 5 (gen/sized #(gen/choose 0 %))))
      ;; => (5 5 5 3 1 4 1 1 5 4)
    \end{lstlisting}
  \end{description}
\end{slide}


\begin{slide}
  \h{Making New Generators}

  \begin{description}
  \item[\texttt{gen/return}] Always the same thing.
    \begin{lstlisting}
      (gen/sample (gen/return 42))
      ;; => (42 42 42 42 42 42 42 42 42 42)
    \end{lstlisting}
  \item[\texttt{gen/one-of}] \textit{Either} this \textit{or} that.
    \begin{lstlisting}
    (gen/sample (gen/one-of [gen/int gen/string-ascii]))
    ;; => ("" "$" 1 2 "tk" "H]=7" 1 0 -4 -6)
    \end{lstlisting}
  \item[\texttt{gen/frequency}] Same as \texttt{gen/one-of}, but with set
    probabilities.
    \begin{lstlisting}
      (gen/sample (gen/frequency [[7 gen/int]
                                  [3 gen/string-ascii]]))
      ;; => ("" 1 1 ".P!" 0 3 -5 4 6 -3)
    \end{lstlisting}
  \end{description}
\end{slide}


\begin{slide}
  \SlideSection{Questions?}
\end{slide}
\end{document}
